<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Westeros Map</title>
<style>
  * { 
    margin: 0; 
    padding: 0; 
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
  }
  body { 
    overflow: hidden; 
    background: #000;
    position: fixed;
    width: 100%;
    height: 100%;
  }
  canvas { 
    display: block; 
    cursor: grab;
    touch-action: none;
  }
  canvas:active { cursor: grabbing; }
  #loading { 
    position: fixed; 
    top: 20px; 
    left: 20px; 
    color: white; 
    background: rgba(0,0,0,0.7); 
    padding: 10px; 
    border-radius: 5px;
    font-family: monospace;
    z-index: 1000;
  }
  #controls {
    position: fixed;
    bottom: 20px;
    right: 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 1000;
  }
  button {
    width: 50px;
    height: 50px;
    background: rgba(255,255,255,0.2);
    border: 2px solid rgba(255,255,255,0.5);
    border-radius: 50%;
    color: white;
    font-size: 24px;
    cursor: pointer;
    backdrop-filter: blur(10px);
  }
  button:active {
    background: rgba(255,255,255,0.4);
  }
</style>
</head>
<body>
<div id="loading">YÃ¼kleniyor: 0/64</div>
<div id="controls">
  <button onclick="zoomIn()">+</button>
  <button onclick="zoomOut()">âˆ’</button>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const loading = document.getElementById('loading');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const tileW = 2348;
const tileH = 3554;
const letters = ["A","B","C","D","E","F","G","H"];

// Harita toplam boyutu
const mapWidth = tileW * 8;
const mapHeight = tileH * 8;

// Tile cache
const tiles = {};
let loadedCount = 0;
let scale = 0.15;
let offsetX = -2000;
let offsetY = -2000;

// ðŸ†• SINIR KONTROLÃœ FONKSÄ°YONU
function constrainView() {
  // HaritanÄ±n ekrandaki boyutu
  const scaledMapWidth = mapWidth * scale;
  const scaledMapHeight = mapHeight * scale;
  
  // Minimum ve maksimum offset deÄŸerleri
  const minOffsetX = canvas.width - scaledMapWidth;
  const maxOffsetX = 0;
  const minOffsetY = canvas.height - scaledMapHeight;
  const maxOffsetY = 0;
  
  // EÄŸer harita ekrandan kÃ¼Ã§Ã¼kse ortala
  if (scaledMapWidth <= canvas.width) {
    offsetX = (canvas.width - scaledMapWidth) / 2;
  } else {
    // Harita ekrandan bÃ¼yÃ¼kse sÄ±nÄ±rlarÄ± uygula
    offsetX = Math.max(minOffsetX, Math.min(maxOffsetX, offsetX));
  }
  
  if (scaledMapHeight <= canvas.height) {
    offsetY = (canvas.height - scaledMapHeight) / 2;
  } else {
    offsetY = Math.max(minOffsetY, Math.min(maxOffsetY, offsetY));
  }
}

// Tile yÃ¼kleme
function loadTile(row, col) {
  const key = `${row}${col}`;
  if (tiles[key]) return tiles[key];
  
  const img = new Image();
  img.src = `/tiles/${row}${col}.png`;
  img.onload = () => {
    loadedCount++;
    loading.textContent = `YÃ¼klendi: ${loadedCount}/64`;
    if (loadedCount === 64) {
      setTimeout(() => loading.style.display = 'none', 1000);
    }
    draw();
  };
  img.onerror = () => {
    console.error(`Tile yÃ¼klenemedi: ${row}${col}`);
  };
  
  tiles[key] = img;
  return img;
}

// TÃ¼m tile'larÄ± yÃ¼kle
for (let r = 0; r < 8; r++) {
  for (let c = 1; c <= 8; c++) {
    loadTile(letters[r], c);
  }
}

// Ã‡izim
function draw() {
  // ðŸ†• Ã‡izmeden Ã¶nce sÄ±nÄ±rlarÄ± kontrol et
  constrainView();
  
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);
  
  for (let r = 0; r < 8; r++) {
    for (let c = 1; c <= 8; c++) {
      const x = (c - 1) * tileW;
      const y = r * tileH;
      
      const screenX = x * scale + offsetX;
      const screenY = y * scale + offsetY;
      const screenW = tileW * scale;
      const screenH = tileH * scale;
      
      if (screenX + screenW < 0 || screenX > canvas.width ||
          screenY + screenH < 0 || screenY > canvas.height) {
        continue;
      }
      
      const tile = tiles[`${letters[r]}${c}`];
      if (tile && tile.complete) {
        ctx.drawImage(tile, x, y);
      }
    }
  }
  
  ctx.restore();
}

// MOUSE EVENTS
let isDragging = false;
let startX, startY;

canvas.addEventListener('mousedown', (e) => {
  isDragging = true;
  startX = e.clientX - offsetX;
  startY = e.clientY - offsetY;
});

canvas.addEventListener('mousemove', (e) => {
  if (isDragging) {
    offsetX = e.clientX - startX;
    offsetY = e.clientY - startY;
    draw();
  }
});

canvas.addEventListener('mouseup', () => isDragging = false);
canvas.addEventListener('mouseleave', () => isDragging = false);

// TOUCH EVENTS
let touches = [];

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  touches = Array.from(e.touches);
  
  if (touches.length === 1) {
    startX = touches[0].clientX - offsetX;
    startY = touches[0].clientY - offsetY;
  }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const newTouches = Array.from(e.touches);
  
  if (newTouches.length === 1 && touches.length === 1) {
    // Tek parmak sÃ¼rÃ¼kleme
    offsetX = newTouches[0].clientX - startX;
    offsetY = newTouches[0].clientY - startY;
    draw();
  } else if (newTouches.length === 2 && touches.length === 2) {
    // Ä°ki parmak pinch zoom
    const oldDist = Math.hypot(
      touches[1].clientX - touches[0].clientX,
      touches[1].clientY - touches[0].clientY
    );
    const newDist = Math.hypot(
      newTouches[1].clientX - newTouches[0].clientX,
      newTouches[1].clientY - newTouches[0].clientY
    );
    
    const oldScale = scale;
    scale *= newDist / oldDist;
    scale = Math.max(0.05, Math.min(scale, 1.5));
    
    // Zoom merkezini iki parmak ortasÄ±na ayarla
    const centerX = (newTouches[0].clientX + newTouches[1].clientX) / 2;
    const centerY = (newTouches[0].clientY + newTouches[1].clientY) / 2;
    
    offsetX = centerX - (centerX - offsetX) * (scale / oldScale);
    offsetY = centerY - (centerY - offsetY) * (scale / oldScale);
    
    draw();
  }
  
  touches = newTouches;
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  touches = Array.from(e.touches);
}, { passive: false });

// Mouse wheel zoom
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  
  const delta = e.deltaY > 0 ? 0.9 : 1.1;
  const oldScale = scale;
  scale *= delta;
  scale = Math.max(0.05, Math.min(scale, 1.5));
  
  const mouseX = e.clientX;
  const mouseY = e.clientY;
  
  offsetX = mouseX - (mouseX - offsetX) * (scale / oldScale);
  offsetY = mouseY - (mouseY - offsetY) * (scale / oldScale);
  
  draw();
}, { passive: false });

// ZOOM BUTONLARI
function zoomIn() {
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const oldScale = scale;
  scale *= 1.3;
  scale = Math.min(scale, 1.5);
  
  offsetX = centerX - (centerX - offsetX) * (scale / oldScale);
  offsetY = centerY - (centerY - offsetY) * (scale / oldScale);
  draw();
}

function zoomOut() {
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const oldScale = scale;
  scale *= 0.77;
  scale = Math.max(scale, 0.05);
  
  offsetX = centerX - (centerX - offsetX) * (scale / oldScale);
  offsetY = centerY - (centerY - offsetY) * (scale / oldScale);
  draw();
}

// Window resize
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  draw();
});

// Ã‡ift dokunuÅŸ zoom
let lastTap = 0;
canvas.addEventListener('touchend', (e) => {
  const currentTime = new Date().getTime();
  const tapLength = currentTime - lastTap;
  
  if (tapLength < 300 && tapLength > 0) {
    e.preventDefault();
    zoomIn();
  }
  
  lastTap = currentTime;
});

// ðŸ†• Ä°lk yÃ¼klemede haritayÄ± ortala
function centerMap() {
  const scaledMapWidth = mapWidth * scale;
  const scaledMapHeight = mapHeight * scale;
  
  offsetX = (canvas.width - scaledMapWidth) / 2;
  offsetY = (canvas.height - scaledMapHeight) / 2;
  
  draw();
}

centerMap();
console.log("Canvas harita hazÄ±r! (SÄ±nÄ±r kontrolÃ¼ aktif)");
</script>
</body>
</html>
