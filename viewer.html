<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Westeros Map</title>
<style>
  * { 
    margin: 0; 
    padding: 0; 
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
  }
  body { 
    overflow: hidden; 
    background: #000;
    position: fixed;
    width: 100%;
    height: 100%;
  }
  canvas { 
    display: block; 
    cursor: grab;
    touch-action: none;
  }
  canvas:active { cursor: grabbing; }
  #loading { 
    position: fixed; 
    top: 20px; 
    left: 20px; 
    color: white; 
    background: rgba(0,0,0,0.7); 
    padding: 10px; 
    border-radius: 5px;
    font-family: monospace;
    z-index: 1000;
  }
  #controls {
    position: fixed;
    bottom: 20px;
    right: 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 1000;
  }
  button {
    width: 50px;
    height: 50px;
    background: rgba(255,255,255,0.2);
    border: 2px solid rgba(255,255,255,0.5);
    border-radius: 50%;
    color: white;
    font-size: 24px;
    cursor: pointer;
    backdrop-filter: blur(10px);
  }
  button:active {
    background: rgba(255,255,255,0.4);
  }
  #hud {
    position: fixed;
    top: 20px;
    right: 20px;
    color: #fff;
    background: rgba(0,0,0,0.6);
    padding: 8px 12px;
    border-radius: 6px;
    font-family: monospace;
    font-size: 12px;
    z-index: 1000;
  }
  #tooltip {
    position: fixed;
    color: #fff;
    background: rgba(0,0,0,0.8);
    padding: 8px 10px;
    border-radius: 6px;
    font-family: sans-serif;
    font-size: 12px;
    max-width: 220px;
    pointer-events: none;
    transform: translate(-50%, -120%);
    white-space: normal;
    z-index: 1000;
    display: none;
  }
  #tooltip h4 {
    margin: 0 0 4px;
    font-size: 13px;
  }
  #editorPanel {
    position: fixed;
    left: 20px;
    bottom: 20px;
    background: rgba(0,0,0,0.75);
    color: #fff;
    font-family: sans-serif;
    padding: 12px;
    border-radius: 10px;
    width: 260px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 1000;
  }
  #editorPanel h3 {
    font-size: 14px;
    margin: 0;
  }
  #editorPanel .mode-buttons {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 6px;
  }
  #editorPanel .mode-buttons button {
    width: 100%;
    height: 34px;
    border-radius: 8px;
    font-size: 13px;
    border: 1px solid rgba(255,255,255,0.4);
    background: rgba(255,255,255,0.12);
  }
  #editorPanel .mode-buttons button.active {
    background: rgba(255,255,255,0.35);
    border-color: #fff;
  }
  #editorPanel label {
    font-size: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
  }
  #editorPanel input[type="range"] {
    width: 120px;
  }
  #editorPanel input[type="color"],
  #editorPanel input[type="text"],
  #editorPanel textarea {
    width: 100%;
    border-radius: 6px;
    border: 1px solid rgba(255,255,255,0.3);
    padding: 6px;
    background: rgba(255,255,255,0.1);
    color: #fff;
  }
  #editorPanel textarea {
    min-height: 60px;
    resize: vertical;
  }
  #editorPanel .row {
    display: flex;
    gap: 8px;
  }
  #editorPanel .row button {
    flex: 1;
    height: 32px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.3);
    background: rgba(255,255,255,0.15);
    color: #fff;
    cursor: pointer;
  }
  #markerEditor {
    display: none;
    gap: 6px;
  }
  #markerEditor.active {
    display: flex;
    flex-direction: column;
  }
  #panelHint {
    font-size: 11px;
    color: rgba(255,255,255,0.75);
    line-height: 1.3;
  }
  #toolbox {
    position: fixed;
    top: 20px;
    left: 20px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    background: rgba(0,0,0,0.75);
    padding: 10px;
    border-radius: 12px;
    z-index: 1000;
    font-family: sans-serif;
    width: 140px;
  }
  #toolbox h3 {
    margin: 0 0 6px;
    font-size: 12px;
    color: rgba(255,255,255,0.9);
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }
  #toolbox button {
    width: 100%;
    height: 36px;
    border-radius: 8px;
    font-size: 13px;
    border: 1px solid rgba(255,255,255,0.4);
    background: rgba(255,255,255,0.12);
    color: #fff;
    cursor: pointer;
  }
  #toolbox button.active {
    background: rgba(255,255,255,0.35);
    border-color: #fff;
  }
  #toolbox .tool-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
</style>
</head>
<body>
<div id="loading">YÃ¼kleniyor: 0/64</div>
<div id="hud">Zoom: 0.15x<br>Koordinat: 0, 0</div>
<div id="tooltip"></div>
<div id="toolbox">
  <h3>AraÃ§lar</h3>
  <div class="tool-group">
    <button id="toolPan" type="button" class="active">Gezin</button>
    <button id="toolDraw" type="button">Boya</button>
    <button id="toolMarker" type="button">Marker</button>
  </div>
  <div class="tool-group">
    <button id="toolCenter" type="button">HaritayÄ± Ortala</button>
    <button id="toolReset" type="button">GÃ¶rÃ¼nÃ¼mÃ¼ SÄ±fÄ±rla</button>
  </div>
</div>
<div id="controls">
  <button onclick="zoomIn()">+</button>
  <button onclick="zoomOut()">âˆ’</button>
</div>
<div id="editorPanel">
  <h3>DÃ¼zenleme Modu</h3>
  <div class="mode-buttons">
    <button id="modePan" type="button" class="active">Gezin</button>
    <button id="modeDraw" type="button">Boya</button>
    <button id="modeMarker" type="button">Marker</button>
  </div>
  <label>FÄ±rÃ§a Rengi <input id="drawColor" type="color" value="#ffcc00"></label>
  <label>FÄ±rÃ§a Boyutu <input id="drawSize" type="range" min="4" max="60" value="18"></label>
  <div class="row">
    <button id="clearDrawings" type="button">BoyalarÄ± Temizle</button>
    <button id="exportDrawings" type="button">BoyalarÄ± Ä°ndir</button>
  </div>
  <div id="markerEditor">
    <input id="markerTitle" type="text" placeholder="Marker baÅŸlÄ±ÄŸÄ±">
    <textarea id="markerDescription" placeholder="AÃ§Ä±klama"></textarea>
    <div class="row">
      <button id="saveMarker" type="button">Kaydet</button>
      <button id="deleteMarker" type="button">Sil</button>
    </div>
  </div>
  <div class="row">
    <button id="exportMarkers" type="button">MarkerlarÄ± Ä°ndir</button>
    <button id="resetMarkers" type="button">MarkerlarÄ± SÄ±fÄ±rla</button>
  </div>
  <div id="panelHint">Boya modunda Ã§izim yapabilir, marker modunda ekleyip dÃ¼zenleyebilirsiniz. DeÄŸiÅŸiklikler bu tarayÄ±cÄ±da saklanÄ±r.</div>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const loading = document.getElementById('loading');
const hud = document.getElementById('hud');
const tooltip = document.getElementById('tooltip');
const modePan = document.getElementById('modePan');
const modeDraw = document.getElementById('modeDraw');
const modeMarker = document.getElementById('modeMarker');
const toolPan = document.getElementById('toolPan');
const toolDraw = document.getElementById('toolDraw');
const toolMarker = document.getElementById('toolMarker');
const toolCenter = document.getElementById('toolCenter');
const toolReset = document.getElementById('toolReset');
const drawColorInput = document.getElementById('drawColor');
const drawSizeInput = document.getElementById('drawSize');
const clearDrawingsButton = document.getElementById('clearDrawings');
const exportDrawingsButton = document.getElementById('exportDrawings');
const exportMarkersButton = document.getElementById('exportMarkers');
const resetMarkersButton = document.getElementById('resetMarkers');
const markerEditor = document.getElementById('markerEditor');
const markerTitle = document.getElementById('markerTitle');
const markerDescription = document.getElementById('markerDescription');
const saveMarkerButton = document.getElementById('saveMarker');
const deleteMarkerButton = document.getElementById('deleteMarker');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const tileW = 2348;
const tileH = 3554;
const letters = ["A","B","C","D","E","F","G","H"];

// Harita toplam boyutu
const mapWidth = tileW * 8;
const mapHeight = tileH * 8;

// Tile cache
const tiles = {};
let loadedCount = 0;
const defaultScale = 0.15;
let scale = defaultScale;
let offsetX = -2000;
let offsetY = -2000;
let markers = [];
const markerRadius = 12;
let mode = 'pan';
let drawings = [];
let activeStroke = null;
let activeMarker = null;
const storageKeys = {
  markers: 'westerosMarkers',
  drawings: 'westerosDrawings'
};

function updateHud(mouseX = null, mouseY = null) {
  if (mouseX !== null && mouseY !== null) {
    const mapPoint = screenToMap(mouseX, mouseY);
    hud.innerHTML = `Zoom: ${scale.toFixed(2)}x<br>Koordinat: ${Math.round(mapPoint.x)}, ${Math.round(mapPoint.y)}<br>Mod: ${mode.toUpperCase()}`;
  } else {
    hud.innerHTML = `Zoom: ${scale.toFixed(2)}x<br>Koordinat: -, -<br>Mod: ${mode.toUpperCase()}`;
  }
}

function mapToScreen(x, y) {
  return {
    x: x * scale + offsetX,
    y: y * scale + offsetY
  };
}

function screenToMap(x, y) {
  return {
    x: (x - offsetX) / scale,
    y: (y - offsetY) / scale
  };
}

function showTooltip(marker, screenX, screenY) {
  tooltip.style.left = `${screenX}px`;
  tooltip.style.top = `${screenY}px`;
  tooltip.innerHTML = `<h4>${marker.name || 'BÃ¶lge'}</h4>${marker.description || ''}`;
  tooltip.style.display = 'block';
}

function hideTooltip() {
  tooltip.style.display = 'none';
}

// ðŸ†• SINIR KONTROLÃœ FONKSÄ°YONU
function constrainView() {
  // HaritanÄ±n ekrandaki boyutu
  const scaledMapWidth = mapWidth * scale;
  const scaledMapHeight = mapHeight * scale;
  
  // Minimum ve maksimum offset deÄŸerleri
  const minOffsetX = canvas.width - scaledMapWidth;
  const maxOffsetX = 0;
  const minOffsetY = canvas.height - scaledMapHeight;
  const maxOffsetY = 0;
  
  // EÄŸer harita ekrandan kÃ¼Ã§Ã¼kse ortala
  if (scaledMapWidth <= canvas.width) {
    offsetX = (canvas.width - scaledMapWidth) / 2;
  } else {
    // Harita ekrandan bÃ¼yÃ¼kse sÄ±nÄ±rlarÄ± uygula
    offsetX = Math.max(minOffsetX, Math.min(maxOffsetX, offsetX));
  }
  
  if (scaledMapHeight <= canvas.height) {
    offsetY = (canvas.height - scaledMapHeight) / 2;
  } else {
    offsetY = Math.max(minOffsetY, Math.min(maxOffsetY, offsetY));
  }
}

function setMode(nextMode) {
  mode = nextMode;
  modePan.classList.toggle('active', mode === 'pan');
  modeDraw.classList.toggle('active', mode === 'draw');
  modeMarker.classList.toggle('active', mode === 'marker');
  toolPan.classList.toggle('active', mode === 'pan');
  toolDraw.classList.toggle('active', mode === 'draw');
  toolMarker.classList.toggle('active', mode === 'marker');
  markerEditor.classList.toggle('active', mode === 'marker');
  activeStroke = null;
  activeMarker = null;
  markerTitle.value = '';
  markerDescription.value = '';
  hideTooltip();
  updateHud();
}

function saveMarkersToStorage() {
  localStorage.setItem(storageKeys.markers, JSON.stringify(markers));
}

function saveDrawingsToStorage() {
  localStorage.setItem(storageKeys.drawings, JSON.stringify(drawings));
}

function loadMarkersFromStorage() {
  try {
    const raw = localStorage.getItem(storageKeys.markers);
    if (raw) {
      const data = JSON.parse(raw);
      if (Array.isArray(data)) {
        markers = data;
        return true;
      }
    }
  } catch (error) {
    console.warn('Marker storage okunamadÄ±.', error);
  }
  return false;
}

function loadDrawingsFromStorage() {
  try {
    const raw = localStorage.getItem(storageKeys.drawings);
    if (raw) {
      const data = JSON.parse(raw);
      if (Array.isArray(data)) {
        drawings = data;
        return true;
      }
    }
  } catch (error) {
    console.warn('Drawing storage okunamadÄ±.', error);
  }
  return false;
}

function hitTestMarker(mapPoint) {
  let hitMarker = null;
  markers.forEach((marker) => {
    const dx = marker.x - mapPoint.x;
    const dy = marker.y - mapPoint.y;
    const dist = Math.hypot(dx, dy);
    if (dist <= 20) {
      hitMarker = marker;
    }
  });
  return hitMarker;
}

function openMarkerEditor(marker) {
  activeMarker = marker;
  markerTitle.value = marker?.name || '';
  markerDescription.value = marker?.description || '';
}

function downloadJson(data, filename) {
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  link.remove();
  URL.revokeObjectURL(url);
}

// Tile yÃ¼kleme
function loadTile(row, col) {
  const key = `${row}${col}`;
  if (tiles[key]) return tiles[key];
  
  const img = new Image();
  img.src = `Tiles/${row}${col}.png`;
  img.onload = () => {
    loadedCount++;
    loading.textContent = `YÃ¼klendi: ${loadedCount}/64`;
    if (loadedCount === 64) {
      setTimeout(() => loading.style.display = 'none', 1000);
    }
    draw();
  };
  img.onerror = () => {
    console.error(`Tile yÃ¼klenemedi: ${row}${col}`);
  };
  
  tiles[key] = img;
  return img;
}

// TÃ¼m tile'larÄ± yÃ¼kle
for (let r = 0; r < 8; r++) {
  for (let c = 1; c <= 8; c++) {
    loadTile(letters[r], c);
  }
}

// Ã‡izim
function draw() {
  // ðŸ†• Ã‡izmeden Ã¶nce sÄ±nÄ±rlarÄ± kontrol et
  constrainView();
  
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);
  
  for (let r = 0; r < 8; r++) {
    for (let c = 1; c <= 8; c++) {
      const x = (c - 1) * tileW;
      const y = r * tileH;
      
      const screenX = x * scale + offsetX;
      const screenY = y * scale + offsetY;
      const screenW = tileW * scale;
      const screenH = tileH * scale;
      
      if (screenX + screenW < 0 || screenX > canvas.width ||
          screenY + screenH < 0 || screenY > canvas.height) {
        continue;
      }
      
      const tile = tiles[`${letters[r]}${c}`];
      if (tile && tile.complete) {
        ctx.drawImage(tile, x, y);
      }
    }
  }

  drawings.forEach((stroke) => {
    if (!stroke.points || stroke.points.length < 2) return;
    ctx.beginPath();
    ctx.strokeStyle = stroke.color;
    ctx.lineWidth = stroke.size;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    stroke.points.forEach((point, index) => {
      if (index === 0) {
        ctx.moveTo(point.x, point.y);
      } else {
        ctx.lineTo(point.x, point.y);
      }
    });
    ctx.stroke();
  });

  markers.forEach((marker) => {
    const screenPos = mapToScreen(marker.x, marker.y);
    if (
      screenPos.x < -markerRadius ||
      screenPos.x > canvas.width + markerRadius ||
      screenPos.y < -markerRadius ||
      screenPos.y > canvas.height + markerRadius
    ) {
      return;
    }
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255, 59, 48, 0.9)';
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2 / scale;
    ctx.arc(marker.x, marker.y, 16, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  });
  
  ctx.restore();
}

// MOUSE EVENTS
let isDragging = false;
let startX, startY;

canvas.addEventListener('mousedown', (e) => {
  if (mode === 'pan') {
    isDragging = true;
    startX = e.clientX - offsetX;
    startY = e.clientY - offsetY;
  } else if (mode === 'draw') {
    const mapPoint = screenToMap(e.clientX, e.clientY);
    activeStroke = {
      color: drawColorInput.value,
      size: Number(drawSizeInput.value),
      points: [mapPoint]
    };
    drawings.push(activeStroke);
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (isDragging) {
    offsetX = e.clientX - startX;
    offsetY = e.clientY - startY;
    draw();
  } else if (mode === 'draw' && activeStroke) {
    activeStroke.points.push(screenToMap(e.clientX, e.clientY));
    draw();
  }
  updateHud(e.clientX, e.clientY);
});

canvas.addEventListener('mouseup', () => {
  isDragging = false;
  if (activeStroke) {
    saveDrawingsToStorage();
    activeStroke = null;
  }
});
canvas.addEventListener('mouseleave', () => {
  isDragging = false;
  if (activeStroke) {
    saveDrawingsToStorage();
    activeStroke = null;
  }
});
canvas.addEventListener('mouseleave', () => {
  updateHud();
});
canvas.addEventListener('click', (e) => {
  const clickPoint = screenToMap(e.clientX, e.clientY);
  const hitMarker = hitTestMarker(clickPoint);

  if (mode === 'marker') {
    if (hitMarker) {
      openMarkerEditor(hitMarker);
    } else {
      const newMarker = {
        id: crypto.randomUUID(),
        x: Math.round(clickPoint.x),
        y: Math.round(clickPoint.y),
        name: '',
        description: ''
      };
      markers.push(newMarker);
      openMarkerEditor(newMarker);
      saveMarkersToStorage();
      draw();
    }
    hideTooltip();
    return;
  }

  if (hitMarker) {
    showTooltip(hitMarker, e.clientX, e.clientY);
  } else {
    hideTooltip();
  }
});

// TOUCH EVENTS
let touches = [];

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  touches = Array.from(e.touches);
  
  if (touches.length === 1) {
    if (mode === 'pan') {
      startX = touches[0].clientX - offsetX;
      startY = touches[0].clientY - offsetY;
    } else if (mode === 'draw') {
      const mapPoint = screenToMap(touches[0].clientX, touches[0].clientY);
      activeStroke = {
        color: drawColorInput.value,
        size: Number(drawSizeInput.value),
        points: [mapPoint]
      };
      drawings.push(activeStroke);
    }
  }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const newTouches = Array.from(e.touches);
  
  if (newTouches.length === 1 && touches.length === 1) {
    if (mode === 'pan') {
      // Tek parmak sÃ¼rÃ¼kleme
      offsetX = newTouches[0].clientX - startX;
      offsetY = newTouches[0].clientY - startY;
      draw();
    } else if (mode === 'draw' && activeStroke) {
      activeStroke.points.push(screenToMap(newTouches[0].clientX, newTouches[0].clientY));
      draw();
    }
  } else if (newTouches.length === 2 && touches.length === 2) {
    // Ä°ki parmak pinch zoom
    const oldDist = Math.hypot(
      touches[1].clientX - touches[0].clientX,
      touches[1].clientY - touches[0].clientY
    );
    const newDist = Math.hypot(
      newTouches[1].clientX - newTouches[0].clientX,
      newTouches[1].clientY - newTouches[0].clientY
    );
    
    const oldScale = scale;
    scale *= newDist / oldDist;
    scale = Math.max(0.05, Math.min(scale, 1.5));
    
    // Zoom merkezini iki parmak ortasÄ±na ayarla
    const centerX = (newTouches[0].clientX + newTouches[1].clientX) / 2;
    const centerY = (newTouches[0].clientY + newTouches[1].clientY) / 2;
    
    offsetX = centerX - (centerX - offsetX) * (scale / oldScale);
    offsetY = centerY - (centerY - offsetY) * (scale / oldScale);
    
    draw();
  }
  
  touches = newTouches;
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  touches = Array.from(e.touches);
  if (activeStroke && touches.length === 0) {
    saveDrawingsToStorage();
    activeStroke = null;
  }
}, { passive: false });

// Mouse wheel zoom
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  
  const delta = e.deltaY > 0 ? 0.9 : 1.1;
  const oldScale = scale;
  scale *= delta;
  scale = Math.max(0.05, Math.min(scale, 1.5));
  
  const mouseX = e.clientX;
  const mouseY = e.clientY;
  
  offsetX = mouseX - (mouseX - offsetX) * (scale / oldScale);
  offsetY = mouseY - (mouseY - offsetY) * (scale / oldScale);
  
  draw();
}, { passive: false });

// ZOOM BUTONLARI
function zoomIn() {
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const oldScale = scale;
  scale *= 1.3;
  scale = Math.min(scale, 1.5);
  
  offsetX = centerX - (centerX - offsetX) * (scale / oldScale);
  offsetY = centerY - (centerY - offsetY) * (scale / oldScale);
  draw();
}

function zoomOut() {
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const oldScale = scale;
  scale *= 0.77;
  scale = Math.max(scale, 0.05);
  
  offsetX = centerX - (centerX - offsetX) * (scale / oldScale);
  offsetY = centerY - (centerY - offsetY) * (scale / oldScale);
  draw();
}

// Window resize
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  draw();
});

// Ã‡ift dokunuÅŸ zoom
let lastTap = 0;
canvas.addEventListener('touchend', (e) => {
  const currentTime = new Date().getTime();
  const tapLength = currentTime - lastTap;
  
  if (tapLength < 300 && tapLength > 0) {
    e.preventDefault();
    zoomIn();
  }
  
  lastTap = currentTime;
});

// ðŸ†• Ä°lk yÃ¼klemede haritayÄ± ortala
function centerMap() {
  const scaledMapWidth = mapWidth * scale;
  const scaledMapHeight = mapHeight * scale;
  
  offsetX = (canvas.width - scaledMapWidth) / 2;
  offsetY = (canvas.height - scaledMapHeight) / 2;
  
  draw();
}

function resetView() {
  scale = defaultScale;
  centerMap();
  updateHud();
}

async function loadMarkers() {
  try {
    const usedStorage = loadMarkersFromStorage();
    if (!usedStorage) {
      const response = await fetch('./markers.json');
      if (!response.ok) {
        throw new Error('Markers yÃ¼klenemedi.');
      }
      const data = await response.json();
      if (Array.isArray(data)) {
        markers = data;
      }
    }
  } catch (error) {
    console.warn('Marker verisi yok veya okunamadÄ±.', error);
  } finally {
    draw();
  }
}

function loadDrawings() {
  loadDrawingsFromStorage();
}

modePan.addEventListener('click', () => setMode('pan'));
modeDraw.addEventListener('click', () => setMode('draw'));
modeMarker.addEventListener('click', () => setMode('marker'));
toolPan.addEventListener('click', () => setMode('pan'));
toolDraw.addEventListener('click', () => setMode('draw'));
toolMarker.addEventListener('click', () => setMode('marker'));
toolCenter.addEventListener('click', () => centerMap());
toolReset.addEventListener('click', () => resetView());

clearDrawingsButton.addEventListener('click', () => {
  if (confirm('BoyalarÄ± temizlemek istiyor musunuz?')) {
    drawings = [];
    saveDrawingsToStorage();
    draw();
  }
});

exportDrawingsButton.addEventListener('click', () => {
  downloadJson(drawings, 'westeros-drawings.json');
});

exportMarkersButton.addEventListener('click', () => {
  downloadJson(markers, 'westeros-markers.json');
});

resetMarkersButton.addEventListener('click', () => {
  if (confirm('MarkerlarÄ± sÄ±fÄ±rlamak istiyor musunuz?')) {
    markers = [];
    saveMarkersToStorage();
    draw();
  }
});

saveMarkerButton.addEventListener('click', () => {
  if (!activeMarker) return;
  activeMarker.name = markerTitle.value.trim();
  activeMarker.description = markerDescription.value.trim();
  saveMarkersToStorage();
  draw();
});

deleteMarkerButton.addEventListener('click', () => {
  if (!activeMarker) return;
  markers = markers.filter((marker) => marker !== activeMarker);
  saveMarkersToStorage();
  activeMarker = null;
  markerTitle.value = '';
  markerDescription.value = '';
  draw();
});

centerMap();
loadMarkers();
loadDrawings();
setMode('pan');
updateHud();
console.log("Canvas harita hazÄ±r! (SÄ±nÄ±r kontrolÃ¼ aktif)");
</script>
</body>
</html>
