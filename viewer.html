<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Westeros Map</title>
<style>
  * { 
    margin: 0; 
    padding: 0; 
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
  }
  body { 
    overflow: hidden; 
    background: #000;
    position: fixed;
    width: 100%;
    height: 100%;
  }
  canvas { 
    display: block; 
    cursor: grab;
    touch-action: none;
  }
  canvas:active { cursor: grabbing; }
  #loading { 
    position: fixed; 
    top: 20px; 
    left: 20px; 
    color: white; 
    background: rgba(0,0,0,0.7); 
    padding: 10px; 
    border-radius: 5px;
    font-family: monospace;
    z-index: 1000;
  }
  #controls {
    position: fixed;
    bottom: 20px;
    right: 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 1000;
  }
  button {
    width: 50px;
    height: 50px;
    background: rgba(255,255,255,0.2);
    border: 2px solid rgba(255,255,255,0.5);
    border-radius: 50%;
    color: white;
    font-size: 24px;
    cursor: pointer;
    backdrop-filter: blur(10px);
  }
  button:active {
    background: rgba(255,255,255,0.4);
  }
  #hud {
    position: fixed;
    top: 20px;
    right: 20px;
    color: #fff;
    background: rgba(0,0,0,0.6);
    padding: 8px 12px;
    border-radius: 6px;
    font-family: monospace;
    font-size: 12px;
    z-index: 1000;
  }
  #topBar {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(0,0,0,0.72);
    padding: 8px;
    border-radius: 10px;
    z-index: 1100;
    font-family: sans-serif;
  }
  #topBar input,
  #topBar select,
  #topBar button {
    height: 34px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.35);
    background: rgba(255,255,255,0.12);
    color: #fff;
    font-size: 13px;
    padding: 0 10px;
  }
  #topBar input {
    width: 200px;
  }
  #topBar button {
    cursor: pointer;
    min-width: 86px;
  }
  #tooltip {
    position: fixed;
    color: #fff;
    background: rgba(0,0,0,0.8);
    padding: 8px 10px;
    border-radius: 6px;
    font-family: sans-serif;
    font-size: 12px;
    max-width: 220px;
    pointer-events: none;
    transform: translate(-50%, -120%);
    white-space: normal;
    z-index: 1000;
    display: none;
  }
  #tooltip h4 {
    margin: 0 0 4px;
    font-size: 13px;
  }
  #editorPanel {
    position: fixed;
    left: 20px;
    bottom: 20px;
    background: rgba(0,0,0,0.75);
    color: #fff;
    font-family: sans-serif;
    padding: 12px;
    border-radius: 10px;
    width: 270px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 1000;
  }
  .panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
  }
  .panel-header button {
    width: auto;
    height: 28px;
    border-radius: 6px;
    font-size: 12px;
    padding: 0 10px;
    border: 1px solid rgba(255,255,255,0.4);
    background: rgba(255,255,255,0.12);
    color: #fff;
  }
  #editorPanelBody,
  #toolboxBody {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  #editorPanel.collapsed #editorPanelBody,
  #toolbox.collapsed #toolboxBody {
    display: none;
  }
  #editorPanel h3 {
    font-size: 14px;
    margin: 0;
  }
  #editorPanel .mode-buttons {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 6px;
  }
  #editorPanel .mode-buttons button {
    width: 100%;
    height: 34px;
    border-radius: 8px;
    font-size: 13px;
    border: 1px solid rgba(255,255,255,0.4);
    background: rgba(255,255,255,0.12);
  }
  #editorPanel .mode-buttons button.active {
    background: rgba(255,255,255,0.35);
    border-color: #fff;
  }
  #editorPanel label {
    font-size: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
  }
  #editorPanel input[type="range"] {
    width: 120px;
  }
  #editorPanel input[type="color"],
  #editorPanel input[type="text"],
  #editorPanel textarea {
    width: 100%;
    border-radius: 6px;
    border: 1px solid rgba(255,255,255,0.3);
    padding: 6px;
    background: rgba(255,255,255,0.1);
    color: #fff;
  }
  #editorPanel textarea {
    min-height: 60px;
    resize: vertical;
  }
  #editorPanel .row {
    display: flex;
    gap: 8px;
  }
  #editorPanel .row button {
    flex: 1;
    height: 32px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.3);
    background: rgba(255,255,255,0.15);
    color: #fff;
    cursor: pointer;
  }
  #markerEditor {
    display: none;
    gap: 6px;
  }
  #markerEditor.active {
    display: flex;
    flex-direction: column;
  }
  #panelHint {
    font-size: 11px;
    color: rgba(255,255,255,0.75);
    line-height: 1.3;
  }
  #toolbox {
    position: fixed;
    top: 20px;
    left: 20px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    background: rgba(0,0,0,0.75);
    padding: 10px;
    border-radius: 12px;
    z-index: 1000;
    font-family: sans-serif;
    width: 160px;
  }
  #toolbox h3 {
    margin: 0 0 6px;
    font-size: 12px;
    color: rgba(255,255,255,0.9);
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }
  #toolbox button {
    width: 100%;
    height: 36px;
    border-radius: 8px;
    font-size: 13px;
    border: 1px solid rgba(255,255,255,0.4);
    background: rgba(255,255,255,0.12);
    color: #fff;
    cursor: pointer;
  }
  #toolbox button.active {
    background: rgba(255,255,255,0.35);
    border-color: #fff;
  }
  #toolbox .tool-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  @media (max-width: 900px) {
    #topBar {
      top: 12px;
      width: calc(100% - 24px);
      left: 12px;
      transform: none;
      flex-wrap: wrap;
      justify-content: center;
    }
    #topBar input {
      width: 160px;
      font-size: 12px;
    }
    #topBar input,
    #topBar select,
    #topBar button {
      height: 30px;
      font-size: 11px;
    }
    #loading,
    #hud,
    #toolbox,
    #editorPanel {
      font-size: 11px;
    }
    #toolbox {
      top: auto;
      bottom: 84px;
      left: 12px;
      width: 130px;
      padding: 8px;
      gap: 6px;
    }
    #toolbox button {
      height: 30px;
      font-size: 11px;
    }
    #editorPanel {
      left: 12px;
      bottom: 12px;
      width: 220px;
      gap: 8px;
      padding: 8px;
    }
    #editorPanel .mode-buttons button,
    #editorPanel .row button {
      height: 28px;
      font-size: 11px;
    }
    #editorPanel input[type="range"] {
      width: 90px;
    }
    #controls {
      right: 12px;
      bottom: 12px;
      gap: 8px;
    }
    #controls button {
      width: 42px;
      height: 42px;
      font-size: 18px;
    }
    #hud {
      right: 12px;
      top: auto;
      bottom: 120px;
      padding: 6px 8px;
      font-size: 10px;
    }
    #loading {
      left: 12px;
      top: 54px;
      padding: 6px 8px;
      font-size: 10px;
    }
  }
</style>
</head>
<body>
<div id="loading">Y√ºkleniyor: 0/64</div>
<div id="hud">Zoom: 0.15x<br>Koordinat: 0, 0</div>
<div id="tooltip"></div>
<div id="topBar">
  <select id="mapSelect" aria-label="Harita se√ßimi"></select>
  <select id="regionSelect" aria-label="B√∂lge se√ßimi"></select>
  <input id="searchInput" type="text" placeholder="B√∂lge veya marker ara...">
  <button id="searchButton" type="button">Git</button>
</div>
<div id="toolbox">
  <div class="panel-header">
    <h3>Ara√ßlar</h3>
    <button id="toggleToolbox" type="button">Gizle</button>
  </div>
  <div id="toolboxBody">
    <div class="tool-group">
      <button id="toolPan" type="button" class="active">Gezin</button>
      <button id="toolDraw" type="button">Boya</button>
      <button id="toolErase" type="button">Silgi</button>
      <button id="toolMarker" type="button">Marker</button>
    </div>
    <div class="tool-group">
      <button id="toolCenter" type="button">Haritayƒ± Ortala</button>
      <button id="toolReset" type="button">G√∂r√ºn√ºm√º Sƒ±fƒ±rla</button>
    </div>
  </div>
</div>
<div id="controls">
  <button onclick="zoomIn()">+</button>
  <button onclick="zoomOut()">‚àí</button>
</div>
<div id="editorPanel">
  <div class="panel-header">
    <h3>D√ºzenleme Modu</h3>
    <button id="toggleEditorPanel" type="button">Gizle</button>
  </div>
  <div id="editorPanelBody">
    <div class="mode-buttons">
      <button id="modePan" type="button" class="active">Gezin</button>
      <button id="modeDraw" type="button">Boya</button>
      <button id="modeErase" type="button">Silgi</button>
      <button id="modeMarker" type="button">Marker</button>
    </div>
    <label>Fƒ±r√ßa Rengi <input id="drawColor" type="color" value="#ffcc00"></label>
    <label>Fƒ±r√ßa Boyutu <input id="drawSize" type="range" min="4" max="60" value="18"></label>
    <div class="row">
      <button id="clearDrawings" type="button">Boyalarƒ± Temizle</button>
      <button id="exportDrawings" type="button">Boyalarƒ± ƒ∞ndir</button>
    </div>
    <div id="markerEditor">
      <input id="markerTitle" type="text" placeholder="Marker ba≈ülƒ±ƒüƒ±">
      <textarea id="markerDescription" placeholder="A√ßƒ±klama"></textarea>
      <label>Marker T√ºr√º
        <select id="markerType">
          <option value="city">≈ûehir</option>
          <option value="castle">Kale</option>
          <option value="battle">Sava≈ü</option>
          <option value="port">Liman</option>
          <option value="religion">ƒ∞nan√ß</option>
          <option value="quest">G√∂rev</option>
        </select>
      </label>
      <div class="row">
        <button id="saveMarker" type="button">Kaydet</button>
        <button id="deleteMarker" type="button">Sil</button>
      </div>
    </div>
    <div class="row">
      <button id="exportMarkers" type="button">Markerlarƒ± ƒ∞ndir</button>
      <button id="resetMarkers" type="button">Markerlarƒ± Sƒ±fƒ±rla</button>
    </div>
    <div id="panelHint">Boya modunda √ßizim yapabilir, silgi ile boyalarƒ± temizleyebilir, marker modunda ekleyip d√ºzenleyebilirsiniz. Deƒüi≈üiklikler bu tarayƒ±cƒ±da saklanƒ±r.</div>
  </div>
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const loading = document.getElementById('loading');
const hud = document.getElementById('hud');
const tooltip = document.getElementById('tooltip');
const modePan = document.getElementById('modePan');
const modeDraw = document.getElementById('modeDraw');
const modeErase = document.getElementById('modeErase');
const modeMarker = document.getElementById('modeMarker');
const toolPan = document.getElementById('toolPan');
const toolDraw = document.getElementById('toolDraw');
const toolErase = document.getElementById('toolErase');
const toolMarker = document.getElementById('toolMarker');
const toolCenter = document.getElementById('toolCenter');
const toolReset = document.getElementById('toolReset');
const drawColorInput = document.getElementById('drawColor');
const drawSizeInput = document.getElementById('drawSize');
const clearDrawingsButton = document.getElementById('clearDrawings');
const exportDrawingsButton = document.getElementById('exportDrawings');
const exportMarkersButton = document.getElementById('exportMarkers');
const resetMarkersButton = document.getElementById('resetMarkers');
const markerEditor = document.getElementById('markerEditor');
const markerTitle = document.getElementById('markerTitle');
const markerDescription = document.getElementById('markerDescription');
const saveMarkerButton = document.getElementById('saveMarker');
const deleteMarkerButton = document.getElementById('deleteMarker');
const markerTypeInput = document.getElementById('markerType');
const mapSelect = document.getElementById('mapSelect');
const regionSelect = document.getElementById('regionSelect');
const searchInput = document.getElementById('searchInput');
const searchButton = document.getElementById('searchButton');
const toolbox = document.getElementById('toolbox');
const editorPanel = document.getElementById('editorPanel');
const toggleToolboxButton = document.getElementById('toggleToolbox');
const toggleEditorPanelButton = document.getElementById('toggleEditorPanel');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const mapConfigs = [
  {
    id: 'westeros',
    label: 'Westeros Ana Harita',
    tilePath: 'Tiles',
    letters: ["A","B","C","D","E","F","G","H"],
    columns: 8,
    tileW: 2348,
    tileH: 3554
  },
  {
    id: 'westeros-copy',
    label: 'Westeros Alternatif',
    tilePath: 'Tiles',
    letters: ["A","B","C","D","E","F","G","H"],
    columns: 8,
    tileW: 2348,
    tileH: 3554
  }
];

const regions = [
  { id: 'north', label: 'North', x: 7700, y: 4200, zoom: 0.28 },
  { id: 'riverlands', label: 'Riverlands', x: 8600, y: 9300, zoom: 0.32 },
  { id: 'vale', label: 'Vale', x: 11900, y: 8400, zoom: 0.36 },
  { id: 'westerlands', label: 'Westerlands', x: 6400, y: 10800, zoom: 0.34 },
  { id: 'reach', label: 'Reach', x: 8300, y: 14700, zoom: 0.3 },
  { id: 'dorne', label: 'Dorne', x: 11000, y: 21400, zoom: 0.26 },
  { id: 'kings-landing', label: 'King's Landing', x: 10300, y: 12250, zoom: 0.45 },
  { id: 'wall', label: 'The Wall', x: 8100, y: 1650, zoom: 0.42 }
];

const markerTypeStyles = {
  city: { label: '≈ûehir', color: 'rgba(255, 195, 0, 0.95)', symbol: '‚óè' },
  castle: { label: 'Kale', color: 'rgba(132, 94, 194, 0.95)', symbol: '‚ñ†' },
  battle: { label: 'Sava≈ü', color: 'rgba(239, 71, 111, 0.95)', symbol: '‚ú¶' },
  port: { label: 'Liman', color: 'rgba(17, 138, 178, 0.95)', symbol: '‚óÜ' },
  religion: { label: 'ƒ∞nan√ß', color: 'rgba(6, 214, 160, 0.95)', symbol: '‚úö' },
  quest: { label: 'G√∂rev', color: 'rgba(255, 255, 255, 0.95)', symbol: '‚òÖ' }
};

let currentMap = mapConfigs[0];
let tileW = currentMap.tileW;
let tileH = currentMap.tileH;
let letters = currentMap.letters;
let mapWidth = tileW * currentMap.columns;
let mapHeight = tileH * letters.length;

// Tile cache
let tiles = {};
let loadedCount = 0;
const defaultScale = 0.15;
let scale = defaultScale;
let offsetX = -2000;
let offsetY = -2000;
let markers = [];
const markerRadius = 12;
let mode = 'pan';
let drawings = [];
let activeStroke = null;
let activeMarker = null;
let isErasing = false;
const storageKeys = {
  markers: 'westerosMarkers',
  drawings: 'westerosDrawings',
  uiState: 'westerosUiState'
};

function updateHud(mouseX = null, mouseY = null) {
  if (mouseX !== null && mouseY !== null) {
    const mapPoint = screenToMap(mouseX, mouseY);
    hud.innerHTML = `Zoom: ${scale.toFixed(2)}x<br>Koordinat: ${Math.round(mapPoint.x)}, ${Math.round(mapPoint.y)}<br>Mod: ${mode.toUpperCase()}`;
  } else {
    hud.innerHTML = `Zoom: ${scale.toFixed(2)}x<br>Koordinat: -, -<br>Mod: ${mode.toUpperCase()}`;
  }
}

function mapToScreen(x, y) {
  return {
    x: x * scale + offsetX,
    y: y * scale + offsetY
  };
}

function screenToMap(x, y) {
  return {
    x: (x - offsetX) / scale,
    y: (y - offsetY) / scale
  };
}

function showTooltip(marker, screenX, screenY) {
  const markerStyle = markerTypeStyles[marker.type] || markerTypeStyles.city;
  tooltip.style.left = `${screenX}px`;
  tooltip.style.top = `${screenY}px`;
  tooltip.innerHTML = `<h4>${markerStyle.symbol} ${marker.name || 'B√∂lge'}</h4><small>${markerStyle.label}</small><br>${marker.description || ''}`;
  tooltip.style.display = 'block';
}

function hideTooltip() {
  tooltip.style.display = 'none';
}

// üÜï SINIR KONTROL√ú FONKSƒ∞YONU
function constrainView() {
  // Haritanƒ±n ekrandaki boyutu
  const scaledMapWidth = mapWidth * scale;
  const scaledMapHeight = mapHeight * scale;
  
  // Minimum ve maksimum offset deƒüerleri
  const minOffsetX = canvas.width - scaledMapWidth;
  const maxOffsetX = 0;
  const minOffsetY = canvas.height - scaledMapHeight;
  const maxOffsetY = 0;
  
  // Eƒüer harita ekrandan k√º√ß√ºkse ortala
  if (scaledMapWidth <= canvas.width) {
    offsetX = (canvas.width - scaledMapWidth) / 2;
  } else {
    // Harita ekrandan b√ºy√ºkse sƒ±nƒ±rlarƒ± uygula
    offsetX = Math.max(minOffsetX, Math.min(maxOffsetX, offsetX));
  }
  
  if (scaledMapHeight <= canvas.height) {
    offsetY = (canvas.height - scaledMapHeight) / 2;
  } else {
    offsetY = Math.max(minOffsetY, Math.min(maxOffsetY, offsetY));
  }
}


function animateTo(mapX, mapY, targetZoom = null) {
  if (targetZoom !== null) {
    scale = Math.max(0.05, Math.min(targetZoom, 1.5));
  }
  offsetX = canvas.width / 2 - mapX * scale;
  offsetY = canvas.height / 2 - mapY * scale;
  draw();
  updateHud();
}

function togglePanel(panelEl, toggleButton) {
  const collapsed = panelEl.classList.toggle('collapsed');
  toggleButton.textContent = collapsed ? 'A√ß' : 'Gizle';
  saveUiState();
}

function saveUiState() {
  const uiState = {
    toolboxCollapsed: toolbox.classList.contains('collapsed'),
    editorCollapsed: editorPanel.classList.contains('collapsed'),
    selectedMapId: currentMap.id
  };
  localStorage.setItem(storageKeys.uiState, JSON.stringify(uiState));
}

function loadUiState() {
  try {
    const raw = localStorage.getItem(storageKeys.uiState);
    if (!raw) return;
    const data = JSON.parse(raw);
    if (data.toolboxCollapsed) {
      toolbox.classList.add('collapsed');
      toggleToolboxButton.textContent = 'A√ß';
    }
    if (data.editorCollapsed) {
      editorPanel.classList.add('collapsed');
      toggleEditorPanelButton.textContent = 'A√ß';
    }
    if (data.selectedMapId) {
      const foundMap = mapConfigs.find((mapConfig) => mapConfig.id === data.selectedMapId);
      if (foundMap) {
        currentMap = foundMap;
      }
    }
  } catch (error) {
    console.warn('UI state okunamadƒ±.', error);
  }
}

function setupSelectors() {
  mapSelect.innerHTML = mapConfigs
    .map((mapConfig) => `<option value="${mapConfig.id}">${mapConfig.label}</option>`)
    .join('');
  mapSelect.value = currentMap.id;

  regionSelect.innerHTML = ['<option value="">B√∂lgeye git...</option>']
    .concat(regions.map((region) => `<option value="${region.id}">${region.label}</option>`))
    .join('');
}

function applyMapConfig(mapConfig, shouldCenter = true) {
  currentMap = mapConfig;
  tileW = currentMap.tileW;
  tileH = currentMap.tileH;
  letters = currentMap.letters;
  mapWidth = tileW * currentMap.columns;
  mapHeight = tileH * letters.length;
  tiles = {};
  loadedCount = 0;
  loading.style.display = 'block';
  loading.textContent = `Y√ºkleniyor: 0/${letters.length * currentMap.columns}`;
  loadAllTiles();
  if (shouldCenter) {
    centerMap();
  } else {
    draw();
  }
  saveUiState();
}

function searchAndNavigate() {
  const query = searchInput.value.trim().toLowerCase();
  if (!query) return;

  const markerHit = markers.find((marker) =>
    marker.name?.toLowerCase().includes(query) ||
    marker.description?.toLowerCase().includes(query)
  );

  if (markerHit) {
    animateTo(markerHit.x, markerHit.y, Math.max(scale, 0.42));
    openMarkerEditor(markerHit);
    setMode('marker');
    return;
  }

  const regionHit = regions.find((region) => region.label.toLowerCase().includes(query));
  if (regionHit) {
    animateTo(regionHit.x, regionHit.y, regionHit.zoom);
    regionSelect.value = regionHit.id;
    return;
  }

  alert('Arama sonucu bulunamadƒ±.');
}

function loadAllTiles() {
  for (let r = 0; r < letters.length; r++) {
    for (let c = 1; c <= currentMap.columns; c++) {
      loadTile(letters[r], c);
    }
  }
}

function setMode(nextMode) {
  mode = nextMode;
  modePan.classList.toggle('active', mode === 'pan');
  modeDraw.classList.toggle('active', mode === 'draw');
  modeErase.classList.toggle('active', mode === 'erase');
  modeMarker.classList.toggle('active', mode === 'marker');
  toolPan.classList.toggle('active', mode === 'pan');
  toolDraw.classList.toggle('active', mode === 'draw');
  toolErase.classList.toggle('active', mode === 'erase');
  toolMarker.classList.toggle('active', mode === 'marker');
  markerEditor.classList.toggle('active', mode === 'marker');
  activeStroke = null;
  activeMarker = null;
  isErasing = false;
  markerTitle.value = '';
  markerDescription.value = '';
  markerTypeInput.value = 'city';
  hideTooltip();
  updateHud();
}

function saveMarkersToStorage() {
  localStorage.setItem(storageKeys.markers, JSON.stringify(markers));
}

function saveDrawingsToStorage() {
  localStorage.setItem(storageKeys.drawings, JSON.stringify(drawings));
}

function loadMarkersFromStorage() {
  try {
    const raw = localStorage.getItem(storageKeys.markers);
    if (raw) {
      const data = JSON.parse(raw);
      if (Array.isArray(data)) {
        markers = data.map((marker) => ({ ...marker, type: marker.type || 'city' }));
        return true;
      }
    }
  } catch (error) {
    console.warn('Marker storage okunamadƒ±.', error);
  }
  return false;
}

function loadDrawingsFromStorage() {
  try {
    const raw = localStorage.getItem(storageKeys.drawings);
    if (raw) {
      const data = JSON.parse(raw);
      if (Array.isArray(data)) {
        drawings = data;
        return true;
      }
    }
  } catch (error) {
    console.warn('Drawing storage okunamadƒ±.', error);
  }
  return false;
}

function hitTestMarker(mapPoint) {
  let hitMarker = null;
  markers.forEach((marker) => {
    const dx = marker.x - mapPoint.x;
    const dy = marker.y - mapPoint.y;
    const dist = Math.hypot(dx, dy);
    if (dist <= 20) {
      hitMarker = marker;
    }
  });
  return hitMarker;
}

function eraseAt(mapPoint) {
  const eraseRadius = Number(drawSizeInput.value) * 1.2;
  let erased = false;
  drawings = drawings.filter((stroke) => {
    if (!stroke.points || stroke.points.length === 0) return false;
    const hit = stroke.points.some((point) => {
      const dx = point.x - mapPoint.x;
      const dy = point.y - mapPoint.y;
      return Math.hypot(dx, dy) <= eraseRadius;
    });
    if (hit) {
      erased = true;
      return false;
    }
    return true;
  });
  if (erased) {
    saveDrawingsToStorage();
    draw();
  }
}

function openMarkerEditor(marker) {
  activeMarker = marker;
  markerTitle.value = marker?.name || '';
  markerDescription.value = marker?.description || '';
  markerTypeInput.value = marker?.type || 'city';
}

function downloadJson(data, filename) {
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  link.remove();
  URL.revokeObjectURL(url);
}

// Tile y√ºkleme
function loadTile(row, col) {
  const key = `${row}${col}`;
  if (tiles[key]) return tiles[key];
  
  const img = new Image();
  img.src = `${currentMap.tilePath}/${row}${col}.png`;
  img.onload = () => {
    loadedCount++;
    loading.textContent = `Y√ºklendi: ${loadedCount}/${letters.length * currentMap.columns}`;
    if (loadedCount === letters.length * currentMap.columns) {
      setTimeout(() => loading.style.display = 'none', 1000);
    }
    draw();
  };
  img.onerror = () => {
    console.error(`Tile y√ºklenemedi: ${row}${col}`);
  };
  
  tiles[key] = img;
  return img;
}

// √áizim
function draw() {
  // üÜï √áizmeden √∂nce sƒ±nƒ±rlarƒ± kontrol et
  constrainView();
  
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);
  
  for (let r = 0; r < letters.length; r++) {
    for (let c = 1; c <= currentMap.columns; c++) {
      const x = (c - 1) * tileW;
      const y = r * tileH;
      
      const screenX = x * scale + offsetX;
      const screenY = y * scale + offsetY;
      const screenW = tileW * scale;
      const screenH = tileH * scale;
      
      if (screenX + screenW < 0 || screenX > canvas.width ||
          screenY + screenH < 0 || screenY > canvas.height) {
        continue;
      }
      
      const tile = tiles[`${letters[r]}${c}`];
      if (tile && tile.complete) {
        ctx.drawImage(tile, x, y);
      }
    }
  }

  drawings.forEach((stroke) => {
    if (!stroke.points || stroke.points.length < 2) return;
    ctx.beginPath();
    ctx.strokeStyle = stroke.color;
    ctx.lineWidth = stroke.size;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    stroke.points.forEach((point, index) => {
      if (index === 0) {
        ctx.moveTo(point.x, point.y);
      } else {
        ctx.lineTo(point.x, point.y);
      }
    });
    ctx.stroke();
  });

  markers.forEach((marker) => {
    const screenPos = mapToScreen(marker.x, marker.y);
    if (
      screenPos.x < -markerRadius ||
      screenPos.x > canvas.width + markerRadius ||
      screenPos.y < -markerRadius ||
      screenPos.y > canvas.height + markerRadius
    ) {
      return;
    }
    const markerStyle = markerTypeStyles[marker.type] || markerTypeStyles.city;
    ctx.beginPath();
    ctx.fillStyle = markerStyle.color;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2 / scale;
    ctx.arc(marker.x, marker.y, 16, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = '#111';
    ctx.font = `${24 / scale}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(markerStyle.symbol, marker.x, marker.y + 1);
  });
  
  ctx.restore();
}

// MOUSE EVENTS
let isDragging = false;
let startX, startY;

canvas.addEventListener('mousedown', (e) => {
  if (mode === 'pan') {
    isDragging = true;
    startX = e.clientX - offsetX;
    startY = e.clientY - offsetY;
  } else if (mode === 'draw') {
    const mapPoint = screenToMap(e.clientX, e.clientY);
    activeStroke = {
      color: drawColorInput.value,
      size: Number(drawSizeInput.value),
      points: [mapPoint]
    };
    drawings.push(activeStroke);
  } else if (mode === 'erase') {
    isErasing = true;
    eraseAt(screenToMap(e.clientX, e.clientY));
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (isDragging) {
    offsetX = e.clientX - startX;
    offsetY = e.clientY - startY;
    draw();
  } else if (mode === 'draw' && activeStroke) {
    activeStroke.points.push(screenToMap(e.clientX, e.clientY));
    draw();
  } else if (mode === 'erase' && isErasing) {
    eraseAt(screenToMap(e.clientX, e.clientY));
  }
  updateHud(e.clientX, e.clientY);
});

canvas.addEventListener('mouseup', () => {
  isDragging = false;
  isErasing = false;
  if (activeStroke) {
    saveDrawingsToStorage();
    activeStroke = null;
  }
});
canvas.addEventListener('mouseleave', () => {
  isDragging = false;
  isErasing = false;
  if (activeStroke) {
    saveDrawingsToStorage();
    activeStroke = null;
  }
});
canvas.addEventListener('mouseleave', () => {
  updateHud();
});
canvas.addEventListener('click', (e) => {
  const clickPoint = screenToMap(e.clientX, e.clientY);
  const hitMarker = hitTestMarker(clickPoint);

  if (mode === 'marker') {
    if (hitMarker) {
      openMarkerEditor(hitMarker);
    } else {
      const newMarker = {
        id: crypto.randomUUID(),
        x: Math.round(clickPoint.x),
        y: Math.round(clickPoint.y),
        name: '',
        description: '',
        type: 'city'
      };
      markers.push(newMarker);
      openMarkerEditor(newMarker);
      saveMarkersToStorage();
      draw();
    }
    hideTooltip();
    return;
  }

  if (hitMarker) {
    showTooltip(hitMarker, e.clientX, e.clientY);
  } else {
    hideTooltip();
  }
});

// TOUCH EVENTS
let touches = [];

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  touches = Array.from(e.touches);
  
  if (touches.length === 1) {
    if (mode === 'pan') {
      startX = touches[0].clientX - offsetX;
      startY = touches[0].clientY - offsetY;
    } else if (mode === 'draw') {
      const mapPoint = screenToMap(touches[0].clientX, touches[0].clientY);
      activeStroke = {
        color: drawColorInput.value,
        size: Number(drawSizeInput.value),
        points: [mapPoint]
      };
      drawings.push(activeStroke);
    } else if (mode === 'erase') {
      isErasing = true;
      eraseAt(screenToMap(touches[0].clientX, touches[0].clientY));
    }
  }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const newTouches = Array.from(e.touches);
  
  if (newTouches.length === 1 && touches.length === 1) {
    if (mode === 'pan') {
      // Tek parmak s√ºr√ºkleme
      offsetX = newTouches[0].clientX - startX;
      offsetY = newTouches[0].clientY - startY;
      draw();
    } else if (mode === 'draw' && activeStroke) {
      activeStroke.points.push(screenToMap(newTouches[0].clientX, newTouches[0].clientY));
      draw();
    } else if (mode === 'erase' && isErasing) {
      eraseAt(screenToMap(newTouches[0].clientX, newTouches[0].clientY));
    }
  } else if (newTouches.length === 2 && touches.length === 2) {
    // ƒ∞ki parmak pinch zoom
    const oldDist = Math.hypot(
      touches[1].clientX - touches[0].clientX,
      touches[1].clientY - touches[0].clientY
    );
    const newDist = Math.hypot(
      newTouches[1].clientX - newTouches[0].clientX,
      newTouches[1].clientY - newTouches[0].clientY
    );
    
    const oldScale = scale;
    scale *= newDist / oldDist;
    scale = Math.max(0.05, Math.min(scale, 1.5));
    
    // Zoom merkezini iki parmak ortasƒ±na ayarla
    const centerX = (newTouches[0].clientX + newTouches[1].clientX) / 2;
    const centerY = (newTouches[0].clientY + newTouches[1].clientY) / 2;
    
    offsetX = centerX - (centerX - offsetX) * (scale / oldScale);
    offsetY = centerY - (centerY - offsetY) * (scale / oldScale);
    
    draw();
  }
  
  touches = newTouches;
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  touches = Array.from(e.touches);
  if (activeStroke && touches.length === 0) {
    saveDrawingsToStorage();
    activeStroke = null;
  }
  if (touches.length === 0) {
    isErasing = false;
  }
}, { passive: false });

// Mouse wheel zoom
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  
  const delta = e.deltaY > 0 ? 0.9 : 1.1;
  const oldScale = scale;
  scale *= delta;
  scale = Math.max(0.05, Math.min(scale, 1.5));
  
  const mouseX = e.clientX;
  const mouseY = e.clientY;
  
  offsetX = mouseX - (mouseX - offsetX) * (scale / oldScale);
  offsetY = mouseY - (mouseY - offsetY) * (scale / oldScale);
  
  draw();
}, { passive: false });

// ZOOM BUTONLARI
function zoomIn() {
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const oldScale = scale;
  scale *= 1.3;
  scale = Math.min(scale, 1.5);
  
  offsetX = centerX - (centerX - offsetX) * (scale / oldScale);
  offsetY = centerY - (centerY - offsetY) * (scale / oldScale);
  draw();
}

function zoomOut() {
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const oldScale = scale;
  scale *= 0.77;
  scale = Math.max(scale, 0.05);
  
  offsetX = centerX - (centerX - offsetX) * (scale / oldScale);
  offsetY = centerY - (centerY - offsetY) * (scale / oldScale);
  draw();
}

// Window resize
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  draw();
});

// √áift dokunu≈ü zoom
let lastTap = 0;
canvas.addEventListener('touchend', (e) => {
  const currentTime = new Date().getTime();
  const tapLength = currentTime - lastTap;
  
  if (tapLength < 300 && tapLength > 0) {
    e.preventDefault();
    zoomIn();
  }
  
  lastTap = currentTime;
});

// üÜï ƒ∞lk y√ºklemede haritayƒ± ortala
function centerMap() {
  const scaledMapWidth = mapWidth * scale;
  const scaledMapHeight = mapHeight * scale;
  
  offsetX = (canvas.width - scaledMapWidth) / 2;
  offsetY = (canvas.height - scaledMapHeight) / 2;
  
  draw();
}

function resetView() {
  scale = defaultScale;
  centerMap();
  updateHud();
}

async function loadMarkers() {
  try {
    const usedStorage = loadMarkersFromStorage();
    if (!usedStorage) {
      const response = await fetch('./markers.json');
      if (!response.ok) {
        throw new Error('Markers y√ºklenemedi.');
      }
      const data = await response.json();
      if (Array.isArray(data)) {
        markers = data.map((marker) => ({ ...marker, type: marker.type || 'city' }));
      }
    }
  } catch (error) {
    console.warn('Marker verisi yok veya okunamadƒ±.', error);
  } finally {
    draw();
  }
}

function loadDrawings() {
  loadDrawingsFromStorage();
}

modePan.addEventListener('click', () => setMode('pan'));
modeDraw.addEventListener('click', () => setMode('draw'));
modeErase.addEventListener('click', () => setMode('erase'));
modeMarker.addEventListener('click', () => setMode('marker'));
toolPan.addEventListener('click', () => setMode('pan'));
toolDraw.addEventListener('click', () => setMode('draw'));
toolErase.addEventListener('click', () => setMode('erase'));
toolMarker.addEventListener('click', () => setMode('marker'));
toolCenter.addEventListener('click', () => centerMap());
toolReset.addEventListener('click', () => resetView());

toggleToolboxButton.addEventListener('click', () => togglePanel(toolbox, toggleToolboxButton));
toggleEditorPanelButton.addEventListener('click', () => togglePanel(editorPanel, toggleEditorPanelButton));

mapSelect.addEventListener('change', (event) => {
  const nextMap = mapConfigs.find((mapConfig) => mapConfig.id === event.target.value);
  if (nextMap) {
    applyMapConfig(nextMap, true);
  }
});

regionSelect.addEventListener('change', (event) => {
  const selectedRegion = regions.find((region) => region.id === event.target.value);
  if (!selectedRegion) return;
  animateTo(selectedRegion.x, selectedRegion.y, selectedRegion.zoom);
});

searchButton.addEventListener('click', () => searchAndNavigate());
searchInput.addEventListener('keydown', (event) => {
  if (event.key === 'Enter') {
    searchAndNavigate();
  }
});

clearDrawingsButton.addEventListener('click', () => {
  if (confirm('Boyalarƒ± temizlemek istiyor musunuz?')) {
    drawings = [];
    saveDrawingsToStorage();
    draw();
  }
});

exportDrawingsButton.addEventListener('click', () => {
  downloadJson(drawings, 'westeros-drawings.json');
});

exportMarkersButton.addEventListener('click', () => {
  downloadJson(markers, 'westeros-markers.json');
});

resetMarkersButton.addEventListener('click', () => {
  if (confirm('Markerlarƒ± sƒ±fƒ±rlamak istiyor musunuz?')) {
    markers = [];
    activeMarker = null;
    markerTitle.value = '';
    markerDescription.value = '';
    markerTypeInput.value = 'city';
    saveMarkersToStorage();
    draw();
  }
});

saveMarkerButton.addEventListener('click', () => {
  if (!activeMarker) return;
  activeMarker.name = markerTitle.value.trim();
  activeMarker.description = markerDescription.value.trim();
  activeMarker.type = markerTypeInput.value;
  saveMarkersToStorage();
  draw();
});

deleteMarkerButton.addEventListener('click', () => {
  if (!activeMarker) return;
  markers = markers.filter((marker) => marker !== activeMarker);
  saveMarkersToStorage();
  activeMarker = null;
  markerTitle.value = '';
  markerDescription.value = '';
  draw();
});

loadUiState();
setupSelectors();
applyMapConfig(currentMap, true);
loadMarkers();
loadDrawings();
setMode('pan');
updateHud();
console.log("Canvas harita hazƒ±r! (Sƒ±nƒ±r kontrol√º aktif)");
</script>
</body>
</html>
